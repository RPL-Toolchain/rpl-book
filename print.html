<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The RPL Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The RPL Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p>Rust has gained significant popularity as a system programming language, valued for its capacity to guarantee memory safety through compile-time verification without sacrificing runtime performance. Since system programming must sometimes perform low-level tasks, Rust also provides unsafe code to bypass the compiler's safety checks, shifting the responsibility for ensuring memory safety to the developer.Therefore, linters are developed to automatically detect common errors and potential misuses of unsafe code. The common approach for existing Rust linters is to embed the checking logic directly into their implementation, which limits their customizability and extensibility. To address this limitation, we introduce RPL, an extensible and customizable Rust linter. The key feature of RPL is the decoupling of checking rules' definition from their detection logic. In particular, RPL consists of two primary components: a Domain-Specific Language (DSL) that allows developers to model/define code patterns, and a detection engine to detect instances of these patterns.</p>
<p>While RPL is still under active development, we intend for this document to serve as a comprehensive guide for future contributors and anyone interested in this work.</p>
<p><em>Carefully we wipe them hour by hour, And let no dust alight.</em></p>
<p>— stuuupidcat, 2025-04-24, Beijing</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-rpl"><a class="header" href="#getting-started-with-rpl">Getting Started with RPL</a></h1>
<h2 id="installation-and-quick-start"><a class="header" href="#installation-and-quick-start">Installation and Quick Start</a></h2>
<ol>
<li>
<p>Clone the repository and enter the directory: <code>git clone https://github.com/RPL-Toolchain/RPL.git &amp;&amp; cd RPL</code></p>
</li>
<li>
<p>Install RPL as a cargo subcommand: <code>cargo install --path .</code></p>
</li>
<li>
<p>Run RPL analysis on your Rust project:</p>
<ul>
<li><code>RPL_PATS=/path/to/RPL/docs/patterns-pest cargo +nightly-2025-02-14 rpl</code> (using built-in RPL pattern definitions based on inline MIR)</li>
<li><code>RUSTFLAGS="-Zinline-mir=false" RPL_PATS=/path/to/RPL/docs/patterns-pest cargo +nightly-2025-02-14 rpl</code> (using built-in RPL pattern definitions based on MIR)</li>
</ul>
</li>
</ol>
<blockquote>
<p>We have the following plans for easing the usage of RPL:</p>
<ul>
<li>Integration of standard patterns: Provide a set of commonly used patterns as part of RPL’s standard library.</li>
<li>Configuration-based pattern management: Introduce a <code>rpl.toml</code> configuration file to manage RPL patterns in a structured and centralized manner.</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-mir"><a class="header" href="#introduction-to-mir">Introduction To MIR</a></h1>
<p>Before delving into the specifics of RPL's pattern modeling language, this chapter will first provide an introduction to Rust's Mid-level Intermediate Representation (MIR). A foundational understanding of MIR is essential, as RPL's entire approach to modeling function logic is directly based on its structure and semantics. Accordingly, the following sections will begin with an overview of MIR before proceeding to a detailed guide on the pattern modeling language itself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intermediate-representation"><a class="header" href="#intermediate-representation">Intermediate Representation</a></h1>
<h2 id="what-is-ir"><a class="header" href="#what-is-ir">What is IR?</a></h2>
<p>In the architecture of a modern compiler, the process of translating human-readable source code into machine-executable code is not a single, monolithic step. Instead, the compiler is typically divided into three main stages: the frontend, the middle-end, and the backend. The Intermediate Representation (IR) is the crucial data structure or code format that acts as the bridge between the frontend and the backend.</p>
<ol>
<li>
<p>Frontend: Parses the source code (like Rust, C++, or Swift), checks for syntax errors, and performs semantic analysis. It then translates the source code into an IR.</p>
</li>
<li>
<p>Middle-end (Optimizer): Takes the IR from the frontend, performs a series of machine-independent optimizations to improve the code's performance and efficiency. The output of this stage is still the (now optimized) IR.</p>
</li>
<li>
<p>Backend (Code Generator): Takes the optimized IR and translates it into machine code for a specific target architecture (like x86-64, ARM64, etc.).</p>
</li>
</ol>
<p>The use of an IR provides a powerful abstraction that decouples the source language from the target machine. This means you can write frontends for many different languages and backends for many different architectures, and have them all work together through the common IR.</p>
<p>LLVM (Low Level Virtual Machine) is a collection of modular and reusable compiler and toolchain technologies. Its Intermediate Representation, LLVM IR, is one of its most influential components. It's a low-level, statically typed, and language-independent IR designed to be the target of a wide variety of frontends and the source for many backends.A key feature of LLVM IR is that it is in Static Single Assignment (SSA) form. In SSA form, every variable is assigned a value exactly once. If a variable's value needs to be updated (e.g., in a loop), a new variable is created instead. This makes many optimizations, like data-flow analysis, significantly simpler to implement.</p>
<p>The following example shows the LLVM IR and machine code of a simple C code:</p>
<p><strong>C code:</strong></p>
<pre><code class="language-c">int add(int a, int b) {
    int result = a + b;
    return result;
}
</code></pre>
<p><strong>LLVM IR:</strong></p>
<pre><code class="language-llvm">; Generated by Clang 17.0.0 (clang-1700.0.13.3)
; clang -S -emit-llvm add.c -o add.ll -O1
; ModuleID = 'add.c'
source_filename = "add.c"
target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128-Fn32"
target triple = "arm64-apple-macosx15.0.0"

; Function Attrs: mustprogress nofree norecurse nosync nounwind ssp willreturn memory(none) uwtable(sync)
define i32 @add(i32 noundef %0, i32 noundef %1) local_unnamed_addr #0 {
  %3 = add nsw i32 %1, %0
  ret i32 %3
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind ssp willreturn memory(none) uwtable(sync) "frame-pointer"="non-leaf" "no-trapping-math"="true" "probe-stack"="__chkstk_darwin" "stack-protector-buffer-size"="8" "target-cpu"="apple-m1" "target-features"="+aes,+altnzcv,+bti,+ccdp,+ccidx,+complxnum,+crc,+dit,+dotprod,+flagm,+fp-armv8,+fp16fml,+fptoint,+fullfp16,+jsconv,+lse,+neon,+pauth,+perfmon,+predres,+ras,+rcpc,+rdm,+sb,+sha2,+sha3,+specrestrict,+ssbs,+v8.1a,+v8.2a,+v8.3a,+v8.4a,+v8.5a,+v8a,+zcm,+zcz" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 2, !"SDK Version", [2 x i32] [i32 15, i32 4]}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 1}
!4 = !{i32 7, !"frame-pointer", i32 1}
!5 = !{!"Apple clang version 17.0.0 (clang-1700.0.13.3)"}
</code></pre>
<p><strong>Machine code:</strong></p>
<pre><code class="language-asm">add:
    lea     eax, [rdi+rsi]
    ret
</code></pre>
<p>The LLVM IR represents a optimized version of a function named <code>@add</code> which computes the sum of two 32-bit integers. It directly takes the two input registers (<code>%0</code> and <code>%1</code>), performs the addition with a single <code>add</code> instruction, and immediately returns the result (<code>%3</code>). The function attributes, such as <code>memory(none)</code> (indicating it doesn't read or write from memory) and <code>willreturn</code>, confirm that the compiler has aggressively optimized the code, eliminating all unnecessary memory operations.</p>
<h2 id="rusts-intermediate-representations"><a class="header" href="#rusts-intermediate-representations">Rust's Intermediate Representations</a></h2>
<p>The Rust compiler transforms source code into machine code through a pipeline of intermediate representations (IRs). This journey from high-level to low-level code involves several key stages:</p>
<ul>
<li><strong>HIR</strong> (High-level IR)</li>
<li><strong>THIR</strong> (Typed HIR)</li>
<li><strong>MIR</strong> (Mid-level IR)</li>
<li><strong>LLVM IR</strong></li>
</ul>
<p>To see this process in action, we'll examine the IRs generated for the following generic <code>add</code> function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;

fn add&lt;T: Add&lt;Output = T&gt;&gt;(a: T, b: T) -&gt; T {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<h3 id="hir---high-level-intermediate-representation"><a class="header" href="#hir---high-level-intermediate-representation">HIR - High-Level Intermediate Representation</a></h3>
<p>The HIR is the primary IR used in most of rustc. It is a compiler-friendly representation of the abstract syntax tree (AST).</p>
<ul>
<li>HIR is generated after parsing, macro expansion, and name resolution.</li>
</ul>
<p><strong>HIR is used for type checking.</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// cargo rustc -- -Z unpretty=hir
#[prelude_import]
use std::prelude::rust_2024::*;
#[attr = MacroUse {arguments: UseAll}]
extern crate std;
use std::ops::Add;

fn add&lt;T&gt;(a: T, b: T) -&gt; T where T: Add&lt;Output = T&gt; { a + b }
<span class="boring">}</span></code></pre></pre>
<h3 id="thir---typed-high-level-intermediate-representation"><a class="header" href="#thir---typed-high-level-intermediate-representation">THIR - Typed High-Level Intermediate Representation</a></h3>
<p>The THIR is a lowered version of the HIR where all the types have been filled in, which is possible after type checking has completed. But it has some other features that distinguish it from the HIR:</p>
<ul>
<li>Like the MIR, the THIR only represents bodies, i.e. "executable code"; this includes function bodies, but also const initializers.</li>
<li>Each body of THIR is only stored temporarily and is dropped as soon as it's no longer needed, as opposed to being stored until the end of the compilation process.</li>
<li>Besides making the types of all nodes available, the THIR also has additional desugaring compared to the HIR. For example, automatic references and dereferences are made explicit, and method calls and overloaded operators are converted into plain function calls. Destruction scopes are also made explicit.</li>
<li>Statements, expressions, and match arms are stored separately.</li>
</ul>
<p><strong>THIR is used for MIR construction, exhaustiveness checking, and unsafety checking.</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// cargo rustc -- -Z unpretty=thir-flat
DefId(0:4 ~ rust_playground[a18a]::add):
Thir {
    body_type: Fn(
        fn(T/#0, T/#0) -&gt; T/#0,
    ),
    arms: [],
    blocks: [
        Block {
            targeted_by_break: false,
            region_scope: Node(5),
            span: src/lib.rs:3:45: 5:2 (#0),
            stmts: [],
            expr: Some(
                e6,
            ),
            safety_mode: Safe,
        },
    ],
    exprs: [
        Expr {
            kind: VarRef {
                id: LocalVarId(
                    HirId(DefId(0:4 ~ rust_playground[a18a]::add).2),
                ),
            },
            ty: T/#0,
            temp_lifetime: TempLifetime {
                temp_lifetime: Some(
                    Node(11),
                ),
                backwards_incompatible: None,
            },
            span: src/lib.rs:4:5: 4:6 (#0),
        },
        Expr {
            kind: Scope {
                region_scope: Node(7),
                lint_level: Explicit(
                    HirId(DefId(0:4 ~ rust_playground[a18a]::add).7),
                ),
                value: e0,
            },
            ty: T/#0,
            temp_lifetime: TempLifetime {
                temp_lifetime: Some(
                    Node(11),
                ),
                backwards_incompatible: None,
            },
            span: src/lib.rs:4:5: 4:6 (#0),
        },
        Expr {
            kind: VarRef {
                id: LocalVarId(
                    HirId(DefId(0:4 ~ rust_playground[a18a]::add).4),
                ),
            },
            ty: T/#0,
            temp_lifetime: TempLifetime {
                temp_lifetime: Some(
                    Node(11),
                ),
                backwards_incompatible: None,
            },
            span: src/lib.rs:4:9: 4:10 (#0),
        },
        Expr {
            kind: Scope {
                region_scope: Node(9),
                lint_level: Explicit(
                    HirId(DefId(0:4 ~ rust_playground[a18a]::add).9),
                ),
                value: e2,
            },
            ty: T/#0,
            temp_lifetime: TempLifetime {
                temp_lifetime: Some(
                    Node(11),
                ),
                backwards_incompatible: None,
            },
            span: src/lib.rs:4:9: 4:10 (#0),
        },
        Expr {
            kind: ZstLiteral {
                user_ty: None,
            },
            ty: FnDef(
                DefId(2:3797 ~ core[f655]::ops::arith::Add::add),
                [
                    T/#0,
                    T/#0,
                ],
            ),
            temp_lifetime: TempLifetime {
                temp_lifetime: Some(
                    Node(11),
                ),
                backwards_incompatible: None,
            },
            span: src/lib.rs:4:5: 4:10 (#0),
        },
        Expr {
            kind: Call {
                ty: FnDef(
                    DefId(2:3797 ~ core[f655]::ops::arith::Add::add),
                    [
                        T/#0,
                        T/#0,
                    ],
                ),
                fun: e4,
                args: [
                    e1,
                    e3,
                ],
                from_hir_call: false,
                fn_span: src/lib.rs:4:5: 4:10 (#0),
            },
            ty: T/#0,
            temp_lifetime: TempLifetime {
                temp_lifetime: Some(
                    Node(11),
                ),
                backwards_incompatible: None,
            },
            span: src/lib.rs:4:5: 4:10 (#0),
        },
        Expr {
            kind: Scope {
                region_scope: Node(6),
                lint_level: Explicit(
                    HirId(DefId(0:4 ~ rust_playground[a18a]::add).6),
                ),
                value: e5,
            },
            ty: T/#0,
            temp_lifetime: TempLifetime {
                temp_lifetime: Some(
                    Node(11),
                ),
                backwards_incompatible: None,
            },
            span: src/lib.rs:4:5: 4:10 (#0),
        },
        Expr {
            kind: Block {
                block: b0,
            },
            ty: T/#0,
            temp_lifetime: TempLifetime {
                temp_lifetime: Some(
                    Node(11),
                ),
                backwards_incompatible: None,
            },
            span: src/lib.rs:3:45: 5:2 (#0),
        },
        Expr {
            kind: Scope {
                region_scope: Node(11),
                lint_level: Explicit(
                    HirId(DefId(0:4 ~ rust_playground[a18a]::add).11),
                ),
                value: e7,
            },
            ty: T/#0,
            temp_lifetime: TempLifetime {
                temp_lifetime: Some(
                    Node(11),
                ),
                backwards_incompatible: None,
            },
            span: src/lib.rs:3:45: 5:2 (#0),
        },
    ],
    stmts: [],
    params: [
        Param {
            pat: Some(
                Pat {
                    ty: T/#0,
                    span: src/lib.rs:3:28: 3:29 (#0),
                    kind: Binding {
                        name: "a",
                        mode: BindingMode(
                            No,
                            Not,
                        ),
                        var: LocalVarId(
                            HirId(DefId(0:4 ~ rust_playground[a18a]::add).2),
                        ),
                        ty: T/#0,
                        subpattern: None,
                        is_primary: true,
                    },
                },
            ),
            ty: T/#0,
            ty_span: Some(
                src/lib.rs:3:31: 3:32 (#0),
            ),
            self_kind: None,
            hir_id: Some(
                HirId(DefId(0:4 ~ rust_playground[a18a]::add).1),
            ),
        },
        Param {
            pat: Some(
                Pat {
                    ty: T/#0,
                    span: src/lib.rs:3:34: 3:35 (#0),
                    kind: Binding {
                        name: "b",
                        mode: BindingMode(
                            No,
                            Not,
                        ),
                        var: LocalVarId(
                            HirId(DefId(0:4 ~ rust_playground[a18a]::add).4),
                        ),
                        ty: T/#0,
                        subpattern: None,
                        is_primary: true,
                    },
                },
            ),
            ty: T/#0,
            ty_span: Some(
                src/lib.rs:3:37: 3:38 (#0),
            ),
            self_kind: None,
            hir_id: Some(
                HirId(DefId(0:4 ~ rust_playground[a18a]::add).3),
            ),
        },
    ],
}
<span class="boring">}</span></code></pre></pre>
<h3 id="mir---mid-level-intermediate-representation"><a class="header" href="#mir---mid-level-intermediate-representation">MIR - Mid-Level Intermediate Representation</a></h3>
<p>MIR is Rust's Mid-level Intermediate Representation. It is constructed from THIR.</p>
<p>Some of the key characteristics of MIR are:</p>
<ul>
<li>It is based on a control-flow graph.</li>
<li>It does not have nested expressions.</li>
<li>All types in MIR are fully explicit.</li>
</ul>
<p>MIR is used for certain flow-sensitive safety checks (borrow checker) , optimization, code generation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// cargo rustc -- -Z unpretty=mir
fn add(_1: T, _2: T) -&gt; T {
    debug a =&gt; _1;
    debug b =&gt; _2;
    let mut _0: T;

    bb0: {
        _0 = &lt;T as Add&gt;::add(move _1, move _2) -&gt; [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-core-concepts-of-mir"><a class="header" href="#the-core-concepts-of-mir">The Core Concepts of MIR</a></h1>
<h2 id="control-flow-graph"><a class="header" href="#control-flow-graph">Control-Flow Graph</a></h2>
<p>The foundational structure of MIR is the Control-Flow Graph. The CFG represents a program as a directed graph where nodes are basic blocks and edges represent the flow of control between them.</p>
<h3 id="basicblock"><a class="header" href="#basicblock">BasicBlock</a></h3>
<p>A BasicBlock is a node in the CFG. It is a straight-line sequence of code with a single entry point and a single exit point, where no branches or jumps occur within the block. In Rust MIR, a basic block is defined as a sequence of zero or more Statements followed by exactly one Terminator. This structure guarantees that control flow can only enter at the beginning of the block and can only exit at the end, via the terminator. There are no branches or jumps in the middle of a basic block.</p>
<p>In current version of rustc (1.91.0-nightly), the data structure of a basic block is defined as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
pub struct BasicBlockData&lt;'tcx&gt; {
    pub statements: Vec&lt;Statement&lt;'tcx&gt;&gt;,
    pub terminator: Option&lt;Terminator&lt;'tcx&gt;&gt;,
    pub is_cleanup: bool, // Whether this block is a cleanup block in an unwind path
}
<span class="boring">}</span></code></pre></pre>
<h3 id="statement"><a class="header" href="#statement">Statement</a></h3>
<p>A Statement represents an action that occurs within a basic block. Crucially, statements have a single, implicit successor: the next statement in the block or, if it is the last one, the block's terminator.</p>
<p>In current version of rustc (1.91.0-nightly), there are 14 kinds of statements.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum StatementKind&lt;'tcx&gt; {
    Assign(Box&lt;(Place&lt;'tcx&gt;, Rvalue&lt;'tcx&gt;)&gt;),
    FakeRead(Box&lt;(FakeReadCause, Place&lt;'tcx&gt;)&gt;),
    SetDiscriminant {
        place: Box&lt;Place&lt;'tcx&gt;&gt;,
        variant_index: VariantIdx,
    },
    Deinit(Box&lt;Place&lt;'tcx&gt;&gt;),
    StorageLive(Local),
    StorageDead(Local),
    Retag(RetagKind, Box&lt;Place&lt;'tcx&gt;&gt;),
    PlaceMention(Box&lt;Place&lt;'tcx&gt;&gt;),
    AscribeUserType(Box&lt;(Place&lt;'tcx&gt;, UserTypeProjection)&gt;, Variance),
    Coverage(CoverageKind),
    Intrinsic(Box&lt;NonDivergingIntrinsic&lt;'tcx&gt;&gt;),
    ConstEvalCounter,
    Nop,
    BackwardIncompatibleDropHint {
        place: Box&lt;Place&lt;'tcx&gt;&gt;,
        reason: BackwardIncompatibleDropReason,
    },
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>In most cases, we only use Assign statements when modeling the logic of a function body.</p>
</blockquote>
<h3 id="terminator"><a class="header" href="#terminator">Terminator</a></h3>
<p>A Terminator is the final instruction in every basic block and is the sole mechanism for directing control flow between blocks. It explicitly defines the successor(s) to the current block. This is where all branching, function calls, returns, and panics are represented. A terminator can have zero successors (e.g., return), one successor (e.g., goto), or multiple successors (e.g., switchInt for an if or match, or Call which has a success path and a potential unwind path).</p>
<p>In current version of rustc (1.91.0-nightly), there are 10 kinds of terminators.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TerminatorKind&lt;'tcx&gt; {
    Goto {
        target: BasicBlock,
    },
    SwitchInt {
        discr: Operand&lt;'tcx&gt;,
        targets: SwitchTargets,
    },
    UnwindResume,
    UnwindTerminate(UnwindTerminateReason),
    Return,
    Unreachable,
    Drop {
        place: Place&lt;'tcx&gt;,
        target: BasicBlock,
        unwind: UnwindAction,
        replace: bool,
        drop: Option&lt;BasicBlock&gt;,
        async_fut: Option&lt;Local&gt;,
    },
    Call {
        func: Operand&lt;'tcx&gt;,
        args: Box&lt;[Spanned&lt;Operand&lt;'tcx&gt;&gt;]&gt;,
        destination: Place&lt;'tcx&gt;,
        target: Option&lt;BasicBlock&gt;,
        unwind: UnwindAction,
        call_source: CallSource,
        fn_span: Span,
    },
    TailCall {
        func: Operand&lt;'tcx&gt;,
        args: Box&lt;[Spanned&lt;Operand&lt;'tcx&gt;&gt;]&gt;,
        fn_span: Span,
    },
    Assert {
        cond: Operand&lt;'tcx&gt;,
        expected: bool,
        msg: Box&lt;AssertMessage&lt;'tcx&gt;&gt;,
        target: BasicBlock,
        unwind: UnwindAction,
    },
    Yield {
        value: Operand&lt;'tcx&gt;,
        resume: BasicBlock,
        resume_arg: Place&lt;'tcx&gt;,
        drop: Option&lt;BasicBlock&gt;,
    },
    CoroutineDrop,
    FalseEdge {
        real_target: BasicBlock,
        imaginary_target: BasicBlock,
    },
    FalseUnwind {
        real_target: BasicBlock,
        unwind: UnwindAction,
    },
    InlineAsm {
        asm_macro: InlineAsmMacro,
        template: &amp;'tcx [InlineAsmTemplatePiece],
        operands: Box&lt;[InlineAsmOperand&lt;'tcx&gt;]&gt;,
        options: InlineAsmOptions,
        line_spans: &amp;'tcx [Span],
        targets: Box&lt;[BasicBlock]&gt;,
        unwind: UnwindAction,
    },
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>In most cases, we only use Goto, SwitchInt, Return, Drop, and Call statements when modeling the logic of a function body.</p>
</blockquote>
<h2 id="desugared-data-representation"><a class="header" href="#desugared-data-representation">Desugared Data Representation</a></h2>
<p>In parallel with simplifying control flow, MIR also simplifies the representation of data and computations. Complex, nested expressions are broken down into a sequence of simple operations on a small set of data-related concepts.</p>
<h3 id="local"><a class="header" href="#local">Local</a></h3>
<p>Memory locations allocated on the stack (conceptually, at least).</p>
<p>This includes function arguments, user-declared variables, and compiler-generated temporary variables used to hold intermediate results. In MIR, locals are not identified by name but by a simple index, such as <code>\_0</code>, <code>\_1</code>, <code>\_2</code>, and so on. The local <code>\_0</code> is always reserved for the return value.</p>
<h3 id="place"><a class="header" href="#place">Place</a></h3>
<p>Expressions that identify a location in memory. It is the MIR equivalent of an "l-value" in C.</p>
<ul>
<li>The simplest Place is just a Local (e.g., _1).</li>
<li>More complex Places are formed by starting with a base Local and applying a sequence of <strong>projections</strong>, such as field access, array indexing, or pointer dereferencing. For example, _1.f represents the field f of the struct stored in local _1, and *_2 represents the memory location pointed to by the local _2.</li>
</ul>
<p>In current version of rustc (1.91.0-nightly), the data structure of a place is defined as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Place&lt;'tcx&gt; {
    pub local: Local,
    pub projection: &amp;'tcx List&lt;PlaceElem&lt;'tcx&gt;&gt;,
}

pub enum PlaceElem&lt;'tcx&gt; {
    Deref,
    Field(FieldIdx, Ty&lt;'tcx&gt;),
    Index(Local),
    ConstantIndex {
        offset: u64,
        min_length: u64,
        from_end: bool,
    },
    Subslice {
        from: u64,
        to: u64,
        from_end: bool,
    },
    Downcast(Option&lt;Symbol&gt;, VariantIdx),
    OpaqueCast(Ty&lt;'tcx&gt;),
    UnwrapUnsafeBinder(Ty&lt;'tcx&gt;),
    Subtype(Ty&lt;'tcx&gt;),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="rvalue"><a class="header" href="#rvalue">Rvalue</a></h3>
<p>Expressions that produce a value.</p>
<p>The "R" stands for the fact that these are the "right-hand side" of an assignment.</p>
<p>In current version of rustc (1.91.0-nightly), the data structure of an rvalue is defined as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Rvalue&lt;'tcx&gt; {
    Use(Operand&lt;'tcx&gt;),
    Repeat(Operand&lt;'tcx&gt;, Const&lt;'tcx&gt;),
    Ref(Region&lt;'tcx&gt;, BorrowKind, Place&lt;'tcx&gt;),
    ThreadLocalRef(DefId),
    RawPtr(RawPtrKind, Place&lt;'tcx&gt;),
    Len(Place&lt;'tcx&gt;),
    Cast(CastKind, Operand&lt;'tcx&gt;, Ty&lt;'tcx&gt;),
    BinaryOp(BinOp, Box&lt;(Operand&lt;'tcx&gt;, Operand&lt;'tcx&gt;)&gt;),
    NullaryOp(NullOp&lt;'tcx&gt;, Ty&lt;'tcx&gt;),
    UnaryOp(UnOp, Operand&lt;'tcx&gt;),
    Discriminant(Place&lt;'tcx&gt;),
    Aggregate(Box&lt;AggregateKind&lt;'tcx&gt;&gt;, IndexVec&lt;FieldIdx, Operand&lt;'tcx&gt;&gt;),
    ShallowInitBox(Operand&lt;'tcx&gt;, Ty&lt;'tcx&gt;),
    CopyForDeref(Place&lt;'tcx&gt;),
    WrapUnsafeBinder(Operand&lt;'tcx&gt;, Ty&lt;'tcx&gt;),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="operand"><a class="header" href="#operand">Operand</a></h3>
<p>The arguments to an Rvalue.</p>
<p>In current version of rustc (1.91.0-nightly), the data structure of an operand is defined as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Operand&lt;'tcx&gt; {
    Copy(Place&lt;'tcx&gt;),
    Move(Place&lt;'tcx&gt;),
    Constant(Box&lt;ConstOperand&lt;'tcx&gt;&gt;),
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpldump_mir-a-gadget-for-mir-dumping"><a class="header" href="#rpldump_mir-a-gadget-for-mir-dumping">rpl::dump_mir: A Gadget for MIR Dumping</a></h1>
<p>To effectively model a code pattern, it is often necessary to first inspect the MIR of the target function. RPL provides the #[rpl::dump_mir] procedural macro to simplify this process. This macro instructs the customized compiler to output the MIR of a target function, providing clear intermediate artifacts that can be used to model/define a new RPL pattern.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Using the macro involves a simple two-step process.</p>
<p><strong>(1) Annotate the Target Function</strong>: First, apply the <code>#[rpl::dump_mir]</code> attribute directly to the function whose MIR you wish to inspect. The macro accepts optional arguments, such as dump_cfg and dump_ddg, to also generate graph visualizations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

#[rpl::dump_mir(dump_cfg, dump_ddg)]
pub unsafe fn get_data&lt;T: ?Sized&gt;(val: *const T) -&gt; *const () {
    unsafe { *mem::transmute::&lt;*const *const T, *const *const ()&gt;(&amp;val) }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>(2) Run the RPL Linter</strong>: Next, run cargo rpl from your project's root directory. For this debugging macro to work, the RPL_PATS environment variable must be set, but it can point to an empty directory if you are only dumping MIR.</p>
<pre><code class="language-bash">RPL_PATS=/path/to/any/pattern/dir cargo rpl
</code></pre>
<h2 id="output"><a class="header" href="#output">Output</a></h2>
<p>The macro produces output in two places: directly in the console and in a new directory in your project root.</p>
<h3 id="console-output"><a class="header" href="#console-output">Console Output</a></h3>
<p>The compiler will print the formatted MIR and other diagnostic information directly to your terminal. This includes a breakdown of the function's local variables and the statements within each basic block.</p>
<pre><code class="language-shell">note: MIR of `get_data`
 --&gt; src/main.rs:4:1
  |
3 |   #[rpl::dump_mir(dump_cfg, dump_ddg)]
  |   ------------------------------------ MIR dumped because of this attribute
...
note: bb0: {
        _4 = &amp;_1;                       // scope[0]
        _3 = &amp;raw const (*_4);          // scope[0]
        _2 = move _3 as *const *const () (Transmute); // scope[0]
        _0 = copy (*_2);                // scope[0]
        return;                         // scope[0]
    }
...
error: abort due to debugging
 --&gt; src/main.rs:3:1
  |
3 | #[rpl::dump_mir(dump_cfg, dump_ddg)]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute
</code></pre>
<p>Note that the process intentionally ends with an <code>error: abort due to debugging</code>. This is a feature designed to remind you to remove the debugging attribute before committing your code.</p>
<h3 id="generated-artifacts"><a class="header" href="#generated-artifacts">Generated Artifacts</a></h3>
<p>The macro will also create a <code>mir_dump</code> directory in your project root containing several files. These artifacts provide a more detailed and persistent record of the function's structure.</p>
<pre><code class="language-bash">mir_dump/
├── rust_playground.get_data.-------.dump_mir..mir
├── rust_playground.get_data.-------.dump_mir..mir.cfg.dot
└── rust_playground.get_data.-------.dump_mir..mir.ddg.dot
</code></pre>
<ul>
<li>
<p><code>.mir</code> file: The raw, textual representation of the function's MIR.</p>
</li>
<li>
<p><code>.cfg.dot</code> file: A representation of the Control-Flow Graph (CFG) in DOT format, which can be visualized with tools like <a href="https://graphviz.org/">Graphviz</a>.</p>
</li>
<li>
<p><code>.ddg.dot</code> file: A representation of the Data-Dependence Graph (DDG) in DOT format.</p>
</li>
</ul>
<p>The following image shows the CFG and DDG of the <code>get_data</code> function.</p>
<p><img src="images/dump-mir-cfg.png" alt="CFG of get_data function" /></p>
<p><img src="images/dump-mir-ddg.png" alt="DDG of get_data function" /></p>
<h3 id="modeling-a-rpl-pattern-from-mir"><a class="header" href="#modeling-a-rpl-pattern-from-mir">Modeling a RPL Pattern from MIR</a></h3>
<p>The primary use of the dumped MIR is to serve as a template for a new RPL pattern. The process involves "hollowing out" the concrete MIR by replacing its specific local variables with abstract metavariables.</p>
<p>For example, consider the dumped MIR above:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Dumped MIR from console
bb0: {
    _4: &amp;*const T = &amp;_1;
    _3: *const *const T = &amp;raw const (*_4);
    _2: *const *const () = move _3 as *const *const () (Transmute);
    _0: *const () = copy (*_2);
    return;
}
<span class="boring">}</span></code></pre></pre>
<p>Converting the raw MIR dump into a functional RPL pattern is a systematic process. The key steps are to add the necessary syntactic structure and then abstract the logic with metavariables.</p>
<ol>
<li><strong>Add <code>let</code> bindings:</strong> Convert each raw MIR assignment (e.g., <code>_4 = &amp;_1;</code>) into a full <code>let</code> statement.</li>
<li><strong>Annotate types:</strong> Use the list of locals provided in the MIR dump to add explicit type annotations for each local variable.</li>
<li><strong>Abstract the pattern with metavariables</strong>. This is where you "hollow out" the concrete MIR to make it a general template. You replace the specific, compiler-generated names for locals and types with descriptive, abstract metavariables (prefixed with <code>$</code>). For example, the concrete local <code>_1</code> of type <code>*const T</code> becomes the abstract statement <code>let $ptr: *const $T = _;</code>. By applying this process to all statements, you transform the specific MIR dump into a reusable pattern.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let $ptr: *const $T = _; // _1
let $ref_to_ptr: &amp;*const $T = &amp;$ptr; // _4
let $ptr_to_ptr_t: *const *const $T = &amp;raw const (*$ref_to_ptr); // _3
let $ptr_to_ptr: *const *const () = move $ptr_to_ptr_t as *const *const () (Transmute); // _2
let $data_ptr: *const () = copy (*$ptr_to_ptr); // _0
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-pattern-modeling-language"><a class="header" href="#the-pattern-modeling-language">The Pattern Modeling Language</a></h1>
<p>The RPL linter consists of two primary components:</p>
<ol>
<li>a domain-specific language for modeling code patterns (It is important to note that while the name RPL originally referred specifically to this modeling language, it has since been broadened to encompass the entire linter toolchain. Consequently, the modeling language itself is currently without a formal name. However, the file extension of the pattern modeling language is still <code>.rpl</code>.)</li>
<li>a general graph matching engine that serves as the backend.</li>
</ol>
<p>This chapter will focus exclusively on providing a comprehensive introduction to this pattern modeling language.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>This section provides a high-level overview of the RPL pattern modeling language. To illustrate its core concepts and syntax, we will use the following example, which models the memory safety vulnerability identified in <code>CVE-2020-25016</code>.</p>
<blockquote>
<p>The detailed information of <code>CVE-2020-25016</code> can be found <a href="https://github.com/RPL-Toolchain/RPL/blob/master/docs/cve-and-ub-notes/memory-safety-related-cves/CVE-2020-25016.md">here</a>.</p>
</blockquote>
<pre><code class="language-Rust">pattern CVE-2020-25016

patt {
    #[diag = "p_unsound_cast"]
    #[const(mutability_1 = "", mutability_2 = "")]
    p_unsound_cast_const[
        $T: type where is_all_safe_trait(self) &amp;&amp; !is_primitive(self)
    ] = fn _ (..) -&gt; _ {
        'cast_from:
        let $from_slice: &amp;[$T] = _;
        let $from_raw: *const [$T] = &amp;raw const *$from_slice;
        let $from_len: usize = PtrMetadata(copy $from_slice);
        let $ty_size: usize = SizeOf($T);
        let $to_ptr_t: *const $T = move $from_raw as *const $T (PtrToPtr);
        let $to_ptr: *const u8 = move $to_ptr_t as *const u8 (PtrToPtr);
        let $to_len: usize = Mul(move $from_len, move $ty_size);
        let $to_raw: *const [u8] = *const [u8] from (copy $to_ptr, copy $to_len);
        'cast_to:
        let $to_slice: &amp;[u8] = &amp;*$to_raw;
    }
}

diag {
    p_unsound_cast = {
        primary(cast_to) = "it is unsound to cast any slice `&amp;{$mutability_1}[{$T}]` to a byte slice `&amp;{$mutability_2}[u8]`",
        label(cast_to)   = "casted to a byte slice here",
        note(cast_from)  = "trying to cast from this value of `&amp;{$mutability_1}[{$T}]` type",
        level            = "deny",
        name             = "unsound_slice_cast",
    }
}
</code></pre>
<p>While this example is intentionally simplified for clarity, it effectively showcases nearly all of the language's key syntactic features. The design of the language is guided by three fundamental principles, all of which are visible in this example:</p>
<h2 id="soc-based-modularization"><a class="header" href="#soc-based-modularization">SoC-Based Modularization</a></h2>
<p>The fundamental design principle of the language is modularization. The pattern is divided into distinct blocks: the <code>patt</code> block contains the core detection logic that describes the structure of the code to be found, while the <code>diag</code> block independently defines the reporting logic (the diagnostic message that will be shown to the user). This separation keeps the rule definition clean and maintainable.</p>
<h2 id="metavariable-based-abstraction"><a class="header" href="#metavariable-based-abstraction">Metavariable-based Abstraction</a></h2>
<p>The core mechanism for abstraction is the metavariable. In the example, <code>$T</code> is a metavariable that acts as a named placeholder prefixed with a dollar sign, which can stand in for any concrete Rust type. This allows the pattern to be abstract and general, capable of matching the vulnerability regardless of the specific slice type involved.</p>
<p>The abstraction provided by metavariables works in concert with Mid-Level Intermediate Representation(MIR)-based modeling
to capture the internal logic of functions at a semantic level. Using a syntax that mirrors MIR provides two key benefits:
First, it makes patterns inherently robust against superficial syntax noise. Different programming styles, such as using a single nested expression versus introducing multiple intermediate variables, often generate the same MIR sequence, allowing a single pattern to detect a logical flaw regardless of its specific source-level implementation. Second, it grants our fundamentally intra-procedural analysis certain inter-procedural capabilities. Compiling with the <code>-Zinline-mir</code> flag instructs the Rust compiler to inline the MIR of eligible called functions into their caller, based on internal heuristics like function size. This action merges the logic of these functions, allowing a single pattern to trace a sequence of operations that crosses the original function boundaries.</p>
<h2 id="predicate-based-refinement"><a class="header" href="#predicate-based-refinement">Predicate-based Refinement</a></h2>
<p>While the MIR-like body defines the structural shape of the pattern, the where clause applies additional semantic constraints. In this case, the predicates <code>is_all_safe_trait</code> and <code>!is_primitive</code> are used to filter the matches for the <code>$T</code> metavariable, ensuring that the rule only flags types where the cast is truly unsound.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-structure-and-code-blocks"><a class="header" href="#file-structure-and-code-blocks">File Structure and Code Blocks</a></h1>
<p>The core syntax of the DSL is shown as follows:</p>
<pre><code class="language-bnf">&lt;rpl-pattern&gt; ::= &lt;rpl-header&gt; &lt;block-list&gt;

&lt;rpl-header&gt; ::= `pattern' &lt;identifier&gt;

&lt;block&gt; ::= &lt;patt-block&gt;
          | &lt;util-block&gt;
          | &lt;diag-block&gt;

&lt;block-list&gt; ::= &lt;block&gt; &lt;block-list&gt; | &lt;empty&gt;

&lt;patt-block&gt; ::= `patt' `{' &lt;use-path-list&gt; &lt;rpl-pattern-item-list&gt; `}'

&lt;util-block&gt; ::= `util' `{' &lt;use-path-list&gt; &lt;rpl-pattern-item-list&gt; `}'

&lt;diag-block&gt; ::= `diag' `{' &lt;diag-block-item-list&gt; `}'

&lt;rpl-pattern-item&gt; ::= &lt;attr-list&gt; &lt;identifier&gt; (&lt;meta-variable-decl-list&gt; | &lt;empty&gt;) `=' &lt;rust-items-or-pattern-operation&gt;
</code></pre>
<p>We can see that:</p>
<ol>
<li>a DSL file begins with a pattern declaration that assigns a name to the detection rule.</li>
<li>Following this declaration, the file is organized into three kinds of code blocks, each of which serves a specific and independent purpose.</li>
</ol>
<h2 id="patt-block"><a class="header" href="#patt-block"><code>patt</code> block</a></h2>
<p>The <code>patt</code> block is the core of the rule definition, containing one or more named pattern items. Syntactically, each pattern item contains three parts: a unique name, a list of metavariable declarations, and a body. The body is used to define the specific content of the pattern and supports the following three forms:</p>
<ol>
<li>modeling one or more abstracted Rust items;</li>
<li>customizing a single pattern;</li>
<li>performing logical operations on multiple patterns.</li>
</ol>
<p>When a pattern item defines a single Rust item, it is typically a function. Alternatively, to model more complex scenarios, a pattern item can define multiple Rust items. A common example of this is pairing a <code>struct</code> or <code>enum</code> definition with its corresponding <code>impl</code> block to represent the relationship between an Abstract Data Type (ADT) and its corresponding methods.</p>
<h2 id="util-block"><a class="header" href="#util-block"><code>util</code> block</a></h2>
<p>The <code>util</code> block serves as a space for auxiliary definitions that support the patterns in the <code>patt</code> block. While the <code>patt</code> items are the public-facing targets for detection, the patterns defined within <code>util</code> blocks are private helpers.These can include reusable sub-patterns that would otherwise clutter the primary pattern definitions. This separation allows for more modular and readable rules by isolating the reusable utility logic from the specific code patterns that are being captured.</p>
<h2 id="diag-block"><a class="header" href="#diag-block"><code>diag</code> block</a></h2>
<p>The <code>diag</code> block is responsible for defining the diagnostic output that is presented to the user when a pattern from the <code>patt</code> block is successfully matched. It maps a pattern's name to a set of diagnostic information, which typically includes the following three components:</p>
<ol>
<li>A severity level, such as <code>deny</code> or <code>warn</code>, to indicate the seriousness of the detected issue;</li>
<li>A primary descriptive message that explains the problem,
which can be accompanied by specific labels that pinpoint locations in the code corresponding to metavariables or specific MIR statements;</li>
<li>supplemental information to aid the developer, such as a note to provide additional context, or a help message that suggests a potential fix or modification.</li>
</ol>
<p>These fields can also include links to relevant documentation for further details. By separating the diagnostic messages from the pattern-matching logic, RPL allows for clear and maintainable rules where the detection and reporting concerns are independently managed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metavariables"><a class="header" href="#metavariables">Metavariables</a></h1>
<p>A metavariable is a named placeholder prefixed with a dollar sign (e.g., <code>$T</code>), which can stand in for a concrete code element. For example, to model a pattern that captures any struct containing a public, constant raw pointer, developer could define the following pattern item (We will introduce the pattern item in the next section, now you can just treat it as a Rust item with a pattern name):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>p [$T: type] = struct $S {
    pub $field: *const $T
}
<span class="boring">}</span></code></pre></pre>
<p>This single pattern can match any struct that has this specific structure, regardless of the names used for the struct itself (<code>$S</code>), its field (<code>$field</code>), or the pointer's underlying type (<code>$T</code>).</p>
<p>Metavariables in RPL fall into two main categories based on whether they require an explicit declaration: implicitly declared and explicitly declared.</p>
<h2 id="implicitly-declared-metavariables"><a class="header" href="#implicitly-declared-metavariables">Implicitly Declared Metavariables</a></h2>
<p>The first category includes <code>$S</code> and <code>$field</code>, which are used to abstract away concrete names. They represent a form of lightweight, contextually-inferred binding. Because their roles as placeholders for a struct or field name are unambiguous from the syntax, they don't require an explicit declaration.</p>
<p>There are two kinds of implicit declaration:</p>
<ol>
<li>abstracting the names of Rust items like structs, enums, functions.</li>
<li>abstracting a local name in MIR.</li>
</ol>
<h2 id="explicitly-declared-metavariables"><a class="header" href="#explicitly-declared-metavariables">Explicitly Declared Metavariables</a></h2>
<p>The second category consists of metavariables that require explicit declaration in the brackets after the pattern item name (<code>[...]</code>). For instance, <code>$T</code> is a <code>type</code> metavariable used in this pattern to abstract the pointer's underlying type. The explicit declaration of these metavariables is necessary for the analysis process to understand their intended purpose and apply specific constraints.</p>
<p>There are three kinds of explicit declaration:</p>
<ol>
<li><code>type</code> metavariable: used to abstract a type.</li>
<li><code>const</code> metavariable: used to abstract a constant value.</li>
<li><code>place</code> metavariable: used to abstract a memory location.</li>
</ol>
<h2 id="special-wildcards-and-placeholders"><a class="header" href="#special-wildcards-and-placeholders">Special Wildcards and Placeholders</a></h2>
<p>In addition to the named metavariables described above, RPL provides two special unnamed wildcards (<code>_</code> and <code>..</code>) to abstract away irrelevant details, enabling the creation of more general and focused patterns.</p>
<h3 id="the-single-item-wildcard-_"><a class="header" href="#the-single-item-wildcard-_">The Single Item Wildcard: <code>_</code></a></h3>
<p>The underscore (<code>_</code>) acts as a wildcard that matches a single, arbitrary item. Its meaning is context-dependent, but it generally signifies that a value is present, but its specific content or origin is not relevant to the pattern.</p>
<p>Its most common and important use is on the right-hand side (r-value) of a mir statement:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let $local: $T = _;
<span class="boring">}</span></code></pre></pre>
<p>This statement asserts that a local variable <code>$local</code> of type <code>$T</code> exists within the function body. It abstracts away the variable's specific origin, meaning it could be initialized from a function parameter, a newly computed value, or any other expression.</p>
<p>The <code>_</code> can also be used in other positions, such as in a function signature (<code>fn _</code>) to match a function with any name, or as a return type (<code>-&gt; _</code>) to match a function with any return type.</p>
<h3 id="the-variadic-wildcard-"><a class="header" href="#the-variadic-wildcard-">The Variadic Wildcard: <code>..</code></a></h3>
<p>The double-dot (<code>..</code>) is a variadic wildcard used to match <strong>zero or more</strong> items in a sequence. Its primary application is for abstracting the arguments of a function.</p>
<p>In a function signature, <code>..</code> can match any number of parameters of any type. For example, the following pattern will match any function, regardless of its arity (the number of arguments it takes):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn $any_function (..) -&gt; _
<span class="boring">}</span></code></pre></pre>
<p>This is crucial for creating patterns that focus on a function's name or its internal logic without being constrained by its specific signature. Furthermore, it can be combined with concrete parameters to find a specific argument anywhere in the list. For instance, <code>fn _ (.., $target: String, ..)</code> matches a function that takes a <code>String</code> at any position in its argument list.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-items"><a class="header" href="#pattern-items">Pattern Items</a></h1>
<h2 id="use-statements"><a class="header" href="#use-statements"><code>use</code> statements</a></h2>
<p>The DSL supports the <code>use</code> statements within both <code>patt</code> and <code>util</code> blocks. Their primary purpose is to import types, such as structs and enums, from external crates and modules into the local scope of the pattern definition. This feature is particularly important for the modeling of function logic, since patterns often need to reference complex types defined in Rust standard libraries. By importing these types, developers can refer to them by their simple names (e.g., <code>Vec</code> instead of <code>alloc::vec::Vec</code>) within the pattern body.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-refinement-and-operation"><a class="header" href="#pattern-refinement-and-operation">Pattern Refinement and Operation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-repetition-tbc"><a class="header" href="#pattern-repetition-tbc">Pattern Repetition (TBC)</a></h1>
<p>A motivating example is described as follows:</p>
<h2 id="clippy-lint-cast-slice-different-sizes"><a class="header" href="#clippy-lint-cast-slice-different-sizes">Clippy lint: <code>cast-slice-different-sizes</code></a></h2>
<p>Checks for <code>as</code> casts between raw pointers to slices with differently sized elements.</p>
<p>The produced raw pointer to a slice <strong>does not update its length metadata</strong>. Producing a slice reference from the raw pointer will either create a slice with less data (which can be surprising) or create a slice with more data and cause Undefined Behavior.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// missing data
let a = [1_i32, 2, 3, 4]; // 4
let p = &amp;a as *const [i32] as *const [u8]; // 16
unsafe {
    println!("{:?}", &amp;*p);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Undefined Behavior (note: also potential alignment issues)
let a = [1_u8, 2, 3, 4]; // 4
let p = &amp;a as *const [u8] as *const [u32]; // 1
unsafe {
    println!("{:?}", &amp;*p); // 4个u32
}
<span class="boring">}</span></code></pre></pre>
<h2 id="a-rpl-pattern-would-cause-a-false-positive"><a class="header" href="#a-rpl-pattern-would-cause-a-false-positive">A RPL pattern would cause a false positive</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern cast-slice-different-sizes

patt {
    p[
        $T: type, // element type before the cast
        $U: type, // element type after the cast
    ] = fn _ (..) -&gt; _ {
        'src:
        let $p: *const [$T] = _;
        'cast:
        let $q: *const [$U] = move $p as *const [$U] (PtrToPtr);
    } where {
        !compatible_layout($T, $U)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The ideal pattern should not match the following code, but the current pattern will match it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: [i32; 3] = [1, 2, 3];
let r_x = &amp;x;

let long_chain_restore =
    r_x as *const [i32]
		as *const [u32]
		as *const [u16]
		as *const [i8]
		as *const [u8]
		as *const [u32];
<span class="boring">}</span></code></pre></pre>
<h2 id="a-solution-inspired-by-the-declarative-macros-in-the-rust-language"><a class="header" href="#a-solution-inspired-by-the-declarative-macros-in-the-rust-language">A solution inspired by the declarative macros in the Rust language</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern cast-slice-different-sizes

patt {
    p[
        $T: type,
        $($U: type)+,
        $($W: type)+,
        $($p_in: local)+,
        $($p_out: local)+,
    ] = fn _ (..) -&gt; _ {
        'src:
        let $src: *const [$T] = _;
        'casts: ${
            let $p_in: *const [$U];
            let $p_out: *const [$W] = move $p_in as *const [$W] (PtrToPtr);
        }+
    } where {
        !compatible_layout($T, tail($($W)+)),
        head($($p_in)+) == $src,
        // list comprehension
        all(
            [nth($($p_out)+, i) == nth($($p_in)+, i+1) | i in [0..len($($p_out)+) - 1]]
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="another-solution-inspired-by-the-semgrep"><a class="header" href="#another-solution-inspired-by-the-semgrep">Another solution inspired by the Semgrep</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern cast-slice-different-sizes

patt {
    p[
        $T: type,
        $N: usize,
        $..Us: [type; $N],
        $..Ws: [type; $N],
    ] = fn _ (..) -&gt; _ {
        'src:
        let $src: *const [$T] = _;
        'casts: {
            let $..p_ins: *const [$..Us];
            let $..p_outs: *const [$..Ws] = move $..p_ins as *const [$..Ws] (PtrToPtr);
        }+
        // Some problem here.
        // What does $..Us and $..Ws mean? (one or multiple?)
    } where {
        ...
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-of-rpl"><a class="header" href="#architecture-of-rpl">Architecture of RPL</a></h1>
<p>This chapter provides an overview of the internal architecture of RPL. It first introduces the algorithmic workflow. Following this, it presents the implementation architecture, detailing how the system is structured into components.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workflow"><a class="header" href="#workflow">Workflow</a></h1>
<p><img src="images/RPL-algorithm-workflow.png" alt="Algorithmic Workflow Architecture" /></p>
<p>The workflow of RPL is shown in the figure above, which conceptually comprises four main activities:
(1) pattern modeling, (2) pattern analysis, (3) target-code analysis, and (4) instance detection.</p>
<p>The process begins when a user models a set of patterns with the pattern modeling DSL,
thereby supplying the inputs for subsequent analysis.
During pattern analysis, each pattern is parsed into an Abstract Syntax Tree (AST) and then processed into its core components:
a symbol table, a structural representation, and a set of semantic constraints.
The symbol tables are used to check the internal errors,
providing a feedback loop for the developer to revise the patterns.
After validation, the structural representation is next transformed into the pattern graph representation.
Target-code analysis compiles the Rust repository and retrieves the compiler’s intermediate representations.
These artifacts are converted into the target graph representation.</p>
<p>Once the graph representations for both the pattern and the target code are ready,
the analysis proceeds to a three-stage matching, filtering, and reporting process.
First, the detection engine uses a graph matching algorithm to find all target code segments that structurally match the pattern's graph.
Next, these candidate matches pass through a filtering stage where semantic constraints declared in the pattern are applied.
Only the matches that satisfy both the structural and semantic conditions are considered valid findings.
Finally, these validated results are processed into compiler-friendly diagnostic messages to report the potential issues in the target code to the developer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementation-architecture"><a class="header" href="#implementation-architecture">Implementation Architecture</a></h1>
<p><img src="images/crate-dependencies.png" alt="Algorithmic Workflow Architecture" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-rpl"><a class="header" href="#contributing-to-rpl">Contributing to RPL</a></h1>
<p>We have outlined our primary project goals and the key tasks we are focused on to achieve them.</p>
<h2 id="our-goals"><a class="header" href="#our-goals">Our Goals</a></h2>
<p>Our long-term vision for RPL is centered on the following objectives:</p>
<ol>
<li>
<p><strong>A Richer Pattern/Knowledge Base</strong>: To create a large-scale, high-quality library of RPL patterns.</p>
</li>
<li>
<p><strong>Proven Real-World Effectiveness</strong>: To detect and report vulnerabilities in real-world Rust repositories.</p>
</li>
<li>
<p><strong>A More User-Friendly Experience</strong>: To improve the usability of the DSL syntax and the supporting toolchain.</p>
</li>
</ol>
<h2 id="key-tasks"><a class="header" href="#key-tasks">Key Tasks</a></h2>
<p>To achieve these goals, we are focused on the following key tasks:</p>
<ol>
<li>
<p><strong>Expanding the Pattern Library</strong>: We are seeking contributions to add new patterns from a variety of sources, including:</p>
<ul>
<li>
<p>Rewriting existing lints from Clippy.</p>
</li>
<li>
<p>Modeling common misuses of unsafe APIs in the Rust standard library.</p>
</li>
<li>
<p>Creating patterns based on published CVEs and security advisories.</p>
</li>
<li>
<p>Rewriting the patterns from other research projects like Rudra and SafeDrop into RPL patterns.</p>
</li>
</ul>
</li>
<li>
<p><strong>Expanding the Predicate Library</strong>: As we add more patterns, we must also enhance their precision and recall. A crucial part of this is building a richer library of predicates.</p>
</li>
<li>
<p><strong>Improving the Core Toolchain</strong>: This includes:</p>
<ul>
<li>
<p>Optimizing the DSL syntax,</p>
</li>
<li>
<p>Developing a configuration system (like <code>rpl.toml</code>) similar to Clippy's, to allow users to customize rules.</p>
</li>
<li>
<p>Refactor the graph matching algorithm logic to support inter-procedural pattern matching (instead of simply using the inline version of MIR).</p>
</li>
<li>
<p>Updating the nightly rustc version that the toolchain depends on periodically.</p>
</li>
<li>
<p>Fixing bugs and updating documentation.</p>
</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-model-an-rpl-pattern"><a class="header" href="#how-to-model-an-rpl-pattern">How to Model an RPL Pattern</a></h1>
<p>This section provides a detailed, step-by-step guide to modeling an RPL pattern, using CVE-2020-35881 as a practical example. We will cover all the necessary commands and processes.</p>
<blockquote>
<p>Note: All commands should be run from the root directory of the RPL project.</p>
</blockquote>
<h2 id="1-obtain-the-mir-of-the-relevant-code-snippet"><a class="header" href="#1-obtain-the-mir-of-the-relevant-code-snippet">1. Obtain the MIR of the Relevant Code Snippet</a></h2>
<p>First, create a new file that reproduces the vulnerable code. This file will also serve as the test case for your new pattern. For this example, create the file <code>tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs</code> and add the following code (this will also serve as the test case for the corresponding pattern):</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

#[rpl::dump_mir(dump_cfg, dump_ddg)]
pub unsafe fn get_data&lt;T: ?Sized&gt;(val: *const T) -&gt; *const () {
    unsafe { *mem::transmute::&lt;*const *const T, *const *const ()&gt;(&amp;val) }
}

#[rpl::dump_mir(dump_cfg, dump_ddg)]
pub unsafe fn get_data_mut&lt;T: ?Sized&gt;(mut val: *mut T) -&gt; *mut () {
    unsafe { *mem::transmute::&lt;*mut *mut T, *mut *mut ()&gt;(&amp;mut val) }
}

fn main() {}</code></pre></pre>
<p>Note the <code>#[rpl::dump_mir]</code> attributes on lines 3 and 8, which instruct the compiler to dump the MIR for these functions.</p>
<p>Next, run the following command to process the file:</p>
<pre><code class="language-bash">cargo uibless tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs
</code></pre>
<p>You may see the following output:</p>
<pre><code class="language-bash">cargo uibless tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.19s
     Running tests/compile-test.rs (target/debug/deps/compile_test-251936bcca420e4b)
tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs ... FAILED

FAILED TEST: ...

error: there were 1 unmatched diagnostics
 --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:3:1
  |
3 | #[rpl::dump_mir(dump_cfg, dump_ddg)]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Error: abort due to debugging
  |

error: there were 1 unmatched diagnostics
 --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:5:15
  |
5 |     unsafe { *mem::transmute::&lt;*const *const T, *const *const ()&gt;(&amp;val) }
  |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Error[rpl::wrong_assumption_of_fat_pointer_layout]: wrong assumption of fat pointer layout
  |

error: there were 1 unmatched diagnostics
 --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:8:1
  |
8 | #[rpl::dump_mir(dump_cfg, dump_ddg)]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Error: abort due to debugging
  |

error: there were 1 unmatched diagnostics
  --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:10:15
   |
10 |     unsafe { *mem::transmute::&lt;*mut *mut T, *mut *mut ()&gt;(&amp;mut val) }
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Error[rpl::wrong_assumption_of_fat_pointer_layout]: wrong assumption of fat pointer layout
   |

error: expected error patterns, but found none

full stderr:
error: wrong assumption of fat pointer layout
  --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:5:15
   |
LL |     unsafe { *mem::transmute::&lt;*const *const T, *const *const ()&gt;(&amp;val) }
   |              -^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |              ||
   |              |ptr transmute here
   |              try to get data ptr from first 8 bytes here
   |
   = help: the Rust Compiler does not expose the layout of fat pointers
   = note: `#[deny(rpl::wrong_assumption_of_fat_pointer_layout)]` on by default

error: wrong assumption of fat pointer layout
  --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:10:15
   |
LL |     unsafe { *mem::transmute::&lt;*mut *mut T, *mut *mut ()&gt;(&amp;mut val) }
   |              -^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |              ||
   |              |ptr transmute here
   |              try to get data ptr from first 8 bytes here
   |
   = help: the Rust Compiler does not expose the layout of fat pointers

note: MIR of `get_data`
  --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:4:1
   |
LL |   #[rpl::dump_mir(dump_cfg, dump_ddg)]
   |   ------------------------------------ MIR dumped because of this attribute
LL | / pub unsafe fn get_data&lt;T: ?Sized&gt;(val: *const T) -&gt; *const () {
LL | |     unsafe { *mem::transmute::&lt;*const *const T, *const *const ()&gt;(&amp;val) }
LL | | }
   | |_^
   |
   = note: see `/Users/stuuupidcat/home/code/projects/RPL/mir_dump/cve_2020_35881_test.get_data.-------.dump_mir..mir` for dumped MIR
   = note: see `/Users/stuuupidcat/home/code/projects/RPL/mir_dump/cve_2020_35881_test.get_data.-------.dump_mir..mir.cfg.dot` for dumped control flow graph
   = note: see `/Users/stuuupidcat/home/code/projects/RPL/mir_dump/cve_2020_35881_test.get_data.-------.dump_mir..mir.ddg.dot` for dumped data dependency graph
note: locals and scopes in this MIR
  --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:4:1
   |
LL |   pub unsafe fn get_data&lt;T: ?Sized&gt;(val: *const T) -&gt; *const () {
   |   ^                                 ---               --------- _0: *const (); // scope[0]
   |   |                                 |
   |  _|                                 _1: *const T; // scope[0]
   | |
LL | |     unsafe { *mem::transmute::&lt;*const *const T, *const *const ()&gt;(&amp;val) }
   | |               ---------------------------------------------------------
   | |               |                                                   |
   | |               |                                                   _3: *const *const T; // scope[0]
   | |               |                                                   _4: &amp;*const T; // scope[0]
   | |               _2: *const *const (); // scope[0]
LL | | }
   | |_^ scope[0]
note: bb0: {
          _4 = &amp;_1; // scope[0]
          _3 = &amp;raw const (*_4); // scope[0]
          _2 = move _3 as *const *const () (Transmute); // scope[0]
          _0 = copy (*_2); // scope[0]
          return; // scope[0]
      }
  --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:6:2
   |
LL |     unsafe { *mem::transmute::&lt;*const *const T, *const *const ()&gt;(&amp;val) }
   |              ----------------------------------------------------------
   |              ||                                                   |
   |              ||                                                   _4 = &amp;_1; // scope[0]
   |              ||                                                   _3 = &amp;raw const (*_4); // scope[0]
   |              |_2 = move _3 as *const *const () (Transmute); // scope[0]
   |              _0 = copy (*_2); // scope[0]
LL | }
   |  ^ return; // scope[0]

note: MIR of `get_data_mut`
  --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:9:1
   |
LL |   #[rpl::dump_mir(dump_cfg, dump_ddg)]
   |   ------------------------------------ MIR dumped because of this attribute
LL | / pub unsafe fn get_data_mut&lt;T: ?Sized&gt;(mut val: *mut T) -&gt; *mut () {
LL | |     unsafe { *mem::transmute::&lt;*mut *mut T, *mut *mut ()&gt;(&amp;mut val) }
LL | | }
   | |_^
   |
   = note: see `/Users/stuuupidcat/home/code/projects/RPL/mir_dump/cve_2020_35881_test.get_data_mut.-------.dump_mir..mir` for dumped MIR
   = note: see `/Users/stuuupidcat/home/code/projects/RPL/mir_dump/cve_2020_35881_test.get_data_mut.-------.dump_mir..mir.cfg.dot` for dumped control flow graph
   = note: see `/Users/stuuupidcat/home/code/projects/RPL/mir_dump/cve_2020_35881_test.get_data_mut.-------.dump_mir..mir.ddg.dot` for dumped data dependency graph
note: locals and scopes in this MIR
  --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:9:1
   |
LL |   pub unsafe fn get_data_mut&lt;T: ?Sized&gt;(mut val: *mut T) -&gt; *mut () {
   |   ^                                     -------             ------- _0: *mut (); // scope[0]
   |   |                                     |
   |  _|                                     _1: *mut T; // scope[0]
   | |
LL | |     unsafe { *mem::transmute::&lt;*mut *mut T, *mut *mut ()&gt;(&amp;mut val) }
   | |               -----------------------------------------------------
   | |               |                                           |
   | |               |                                           _3: *mut *mut T; // scope[0]
   | |               |                                           _4: &amp;mut *mut T; // scope[0]
   | |               _2: *mut *mut (); // scope[0]
LL | | }
   | |_^ scope[0]
note: bb0: {
          _4 = &amp;mut _1; // scope[0]
          _3 = &amp;raw mut (*_4); // scope[0]
          _2 = move _3 as *mut *mut () (Transmute); // scope[0]
          _0 = copy (*_2); // scope[0]
          return; // scope[0]
      }
  --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:11:2
   |
LL |     unsafe { *mem::transmute::&lt;*mut *mut T, *mut *mut ()&gt;(&amp;mut val) }
   |              ------------------------------------------------------
   |              ||                                           |
   |              ||                                           _4 = &amp;mut _1; // scope[0]
   |              ||                                           _3 = &amp;raw mut (*_4); // scope[0]
   |              |_2 = move _3 as *mut *mut () (Transmute); // scope[0]
   |              _0 = copy (*_2); // scope[0]
LL | }
   |  ^ return; // scope[0]

error: abort due to debugging
  --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:3:1
   |
LL | #[rpl::dump_mir(dump_cfg, dump_ddg)]
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute
   |
   = note: `#[rpl::dump_hir]`, `#[rpl::print_hir]` and `#[rpl::dump_mir]` are only used for debugging
   = note: this error is to remind you removing these attributes

error: abort due to debugging
  --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:8:1
   |
LL | #[rpl::dump_mir(dump_cfg, dump_ddg)]
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute
   |
   = note: `#[rpl::dump_hir]`, `#[rpl::print_hir]` and `#[rpl::dump_mir]` are only used for debugging
   = note: this error is to remind you removing these attributes

error: aborting due to 4 previous errors


full stdout:


FAILURES:
    tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs

test result: FAIL. 1 failed; 98 filtered out


thread 'main' panicked at tests/compile-test.rs:212:6:
called `Result::unwrap()` on an `Err` value: tests failed

Location:
    /Users/stuuupidcat/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ui_test-0.29.2/src/lib.rs:369:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
error: test failed, to rerun pass `--test compile-test`
</code></pre>
<p>You may see a series of errors. This is expected and can be disregarded. The output in this case indicates two things:</p>
<ol>
<li>You have successfully dumped the MIR. The process ends with an <code>Error: abort due to debugging</code> message because #[rpl::dump_mir] is a debug-only attribute.</li>
<li>You may see an error: <code>there were 1 unmatched diagnostics</code> message. This occurs because the pattern for this CVE already exists in our library, and it has correctly detected the vulnerability in your new test file. However, you haven't added/labeled the possible error output to the test file, so the 'diagnostics is unmatched'.</li>
</ol>
<p>After running the command, you will find a new <code>mir_dump</code> directory in the project root:</p>
<pre><code class="language-bash">➜  RPL git:(dev) ✗ la mir_dump
total 48
-rw-r--r--@ 1 stuuupidcat  staff   1.3K  9 15 17:30 cve_2020_35881_test.get_data_mut.-------.dump_mir..mir
-rw-r--r--@ 1 stuuupidcat  staff   365B  9 15 17:30 cve_2020_35881_test.get_data_mut.-------.dump_mir..mir.cfg.dot
-rw-r--r--@ 1 stuuupidcat  staff   1.7K  9 15 17:30 cve_2020_35881_test.get_data_mut.-------.dump_mir..mir.ddg.dot
-rw-r--r--@ 1 stuuupidcat  staff   1.3K  9 15 17:30 cve_2020_35881_test.get_data.-------.dump_mir..mir
-rw-r--r--@ 1 stuuupidcat  staff   367B  9 15 17:30 cve_2020_35881_test.get_data.-------.dump_mir..mir.cfg.dot
-rw-r--r--@ 1 stuuupidcat  staff   1.7K  9 15 17:30 cve_2020_35881_test.get_data.-------.dump_mir..mir.ddg.dot
</code></pre>
<p>This directory contains the raw MIR (<code>.mir</code>), Control-Flow Graph (<code>.cfg.dot</code>), and Data-Dependence Graph (<code>.ddg.dot</code>) for the target functions. The <code>.dot</code> files can be visualized using tools like Graphviz.</p>
<p>Let's examine the MIR for <code>get_data_mut</code> by opening the corresponding <code>cve_2020_35881_test.get_data_mut.-------.dump_mir..mir</code> file. You will see the following content:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_data_mut(_1: *mut T) -&gt; *mut () {
    debug val =&gt; _1;                     // in scope 0 at tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:9:39: 9:46
    let mut _0: *mut ();                 // return place in scope 0 at tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:9:59: 9:66
    let mut _2: *mut *mut ();            // in scope 0 at tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:10:15: 10:68
    let mut _3: *mut *mut T;             // in scope 0 at tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:10:59: 10:67
    let mut _4: &amp;mut *mut T;             // in scope 0 at tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:10:59: 10:67

    bb0: {
        _4 = &amp;mut _1;                    // scope 0 at tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:10:59: 10:67
        _3 = &amp;raw mut (*_4);             // scope 0 at tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:10:59: 10:67
        _2 = move _3 as *mut *mut () (Transmute); // scope 0 at tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:10:15: 10:68
        _0 = copy (*_2);                 // scope 0 at tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:10:14: 10:68
        return;                          // scope 0 at tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:11:2: 11:2
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is the raw material for our pattern. In this case, all of the MIR statements are relevant and will be modeled.</p>
<h2 id="2-abstract-the-mir-to-form-a-pattern"><a class="header" href="#2-abstract-the-mir-to-form-a-pattern">2. Abstract the MIR to Form a Pattern</a></h2>
<p>Now that we have the MIR, the next step is to convert it into a generic RPL pattern. Create a new file at <code>docs/patterns-pest/cve/cve_2020_35881.rpl</code> and follow these steps.</p>
<p>First, give your pattern a name:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern CVE-2020-35881
<span class="boring">}</span></code></pre></pre>
<p>Next, add a patt block and begin translating the MIR statements. The process involves "hollowing out" the concrete MIR by replacing specific locals and types with abstract metavariables.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>patt {
    const_const[
        $T: type,
    ] = {
        fn _(..) -&gt; _ {
            let $ptr: *const $T = _;
            // _4 = &amp;_1;
            let $ref_to_ptr: &amp;*const $T = &amp;$ptr;
            // _3 = &amp;raw const (*_4);
            let $ptr_to_ptr_t: *const *const $T = &amp;raw const (*$ref_to_ptr);
            // _2 = move _3 as *const *const () (Transmute);
            'ptr_transmute:
            let $ptr_to_ptr: *const *const() = move $ptr_to_ptr_t as *const *const () (Transmute);
            // _0 = copy (*_2);
            'data_ptr_get:
            let $data_ptr: *const () = copy (*$ptr_to_ptr);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In the <code>const_const</code> pattern item above (which models the <code>get_data</code> function), the first statement <code>let $ptr: *const $T = _;</code> indicates that we are looking for a pointer of type <code>*const $T</code> that comes from an arbitrary source (<code>_</code>). The subsequent statements directly correspond to the MIR from the <code>get_data</code> function.</p>
<p>Note the key differences between the raw MIR and the RPL pattern:</p>
<ol>
<li>
<p>Concrete local (<code>_1</code>, <code>_2</code>, etc.) have been replaced with abstract metavariables with descriptive names (e.g., <code>$ptr</code>, <code>$ref_to_ptr</code>).</p>
</li>
<li>
<p>The <code>let</code> keyword has been added to form a valid RPL statement declaration.</p>
</li>
<li>
<p>The <code>'ptr_transmute:</code> and <code>'data_ptr_get:</code> labels have been added to key statements. These labels allow us to reference these specific points in the code when creating diagnostic messages.</p>
</li>
</ol>
<h2 id="3-add-diagnostic-information"><a class="header" href="#3-add-diagnostic-information">3. Add Diagnostic Information</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>diag {
    const_const = {
        primary(ptr_transmute) = "wrong assumption of fat pointer layout",
        label(ptr_transmute)   = "ptr transmute here",
        label(data_ptr_get)    = "try to get data ptr from first 8 bytes here",
        help                   = "the Rust Compiler does not expose the layout of fat pointers",
        name                   = "wrong_assumption_of_fat_pointer_layout",
        level                  = "deny",
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The block maps a diagnostic name (here, <code>const_const</code>) to a set of properties that build the final compiler output.</p>
<h2 id="4-complete-the-rule-with-all-variants"><a class="header" href="#4-complete-the-rule-with-all-variants">4. Complete the Rule with All Variants</a></h2>
<p>Finally, we complete the rule by adding the pattern for the mutable case (<code>mut_mut</code>) and reusing the diagnostic message from the <code>const_const</code> pattern. The complete file looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern CVE-2020-35881

patt {
    #[diag = "fat_pointer"]
    const_const[
        $T: type,
    ] = {
        fn _ (..) -&gt; _ {
            let $ptr: *const $T = _;
            let $ref_to_ptr: &amp;*const $T = &amp;$ptr;
            let $ptr_to_ptr_t: *const *const $T = &amp;raw const (*$ref_to_ptr);
            'ptr_transmute:
            let $ptr_to_ptr: *const *const() = move $ptr_to_ptr_t as *const *const () (Transmute);
            'data_ptr_get:
            let $data_ptr: *const () = copy (*$ptr_to_ptr);
        }
    }
    #[diag = "fat_pointer"]
    mut_mut[
        $T: type,
    ] = {
        fn _ (..) -&gt; _ {
            let $ptr: *mut $T = _;
            let $ref_to_ptr: &amp;mut *mut $T = &amp;mut $ptr;
            let $ptr_to_ptr_t: *mut *mut $T = &amp;raw mut (*$ref_to_ptr);
            'ptr_transmute:
            let $ptr_to_ptr: *mut *mut() = move $ptr_to_ptr_t as *mut *mut () (Transmute);
            'data_ptr_get:
            let $data_ptr: *mut () = copy (*$ptr_to_ptr);
        }
    }
}

diag {
    fat_pointer = {
        primary(ptr_transmute) = "wrong assumption of fat pointer layout",
        label(ptr_transmute)   = "ptr transmute here",
        label(data_ptr_get)    = "try to get data ptr from first 8 bytes here",
        help                   = "the Rust Compiler does not expose the layout of fat pointers",
        name                   = "wrong_assumption_of_fat_pointer_layout",
        level                  = "deny",
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The final rule contains two pattern items, <code>const_const</code> and <code>mut_mut</code>, to handle both immutable and mutable pointer variations. The <code>#[diag = "fat_pointer"]</code> attribute links both patterns to the same diagnostic message defined in the diag block.</p>
<blockquote>
<p>One might also consider the <code>const_mut</code> and <code>mut_const</code> variants. We have intentionally omitted a mechanism for metavariables to abstract over mutability due to a design trade-off. Although such a feature would allow the four mutability variants to be consolidated into one concise pattern, we believe this would sacrifice the clarity and readability of the rule.</p>
</blockquote>
<p>In the next chapter, we will introduce how to ensure the correctness of the pattern through unit tests.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-test-an-rpl-pattern"><a class="header" href="#how-to-test-an-rpl-pattern">How to Test an RPL Pattern</a></h1>
<p>The RPL toolchain is implemented as a plugin-based <code>rustc</code> customization, adding its custom logic via callbacks into the standard compilation process. Consequently, we can leverage <code>rustc</code>'s <a href="https://rustc-dev-guide.rust-lang.org/tests/ui.html">UI testing framework</a> to test RPL patterns.</p>
<p>Testing serves two critical purposes in the RPL development lifecycle:</p>
<ol>
<li><strong>During Development:</strong> Tests are used to verify that a pattern produces the expected diagnostic output on a code snippet known to be vulnerable. This stage is also crucial for refining the pattern to maximize its precision and recall.</li>
<li><strong>During Maintenance:</strong> Tests act as regression guards. They ensure that patterns remain effective over time, especially when upgrading to a new nightly <code>rustc</code> version, as the underlying MIR representation can change. Failing tests indicate that a pattern needs to be updated to remain valid.</li>
</ol>
<h2 id="the-role-of-ui-tests"><a class="header" href="#the-role-of-ui-tests">The Role of UI Tests</a></h2>
<p>The primary purpose of <code>rustc</code>'s UI tests is to validate the console output of the compiler. This aligns perfectly with RPL's operational model, which is designed to generate specific diagnostic messages (i.e., console output) when it detects a matching code pattern.</p>
<h2 id="writing-a-ui-test-for-an-rpl-pattern"><a class="header" href="#writing-a-ui-test-for-an-rpl-pattern">Writing a UI Test for an RPL Pattern</a></h2>
<p>Continuing with the <code>cve_2020_35881_test.rs</code> file from the previous section, we will now convert it into a proper UI test. This process involves cleaning up the file, generating the expected error output, and annotating the source code to match that output.</p>
<h3 id="step-1-remove-debug-attributes"><a class="header" href="#step-1-remove-debug-attributes">Step 1: Remove Debug Attributes</a></h3>
<p>First, remove the <code>#[rpl::dump_mir]</code> attributes from the test file. These are used only for the initial debugging and MIR generation phase and are not part of the final test case.</p>
<h3 id="step-2-generate-the-expected-output-stderr"><a class="header" href="#step-2-generate-the-expected-output-stderr">Step 2: Generate the Expected Output (<code>.stderr</code>)</a></h3>
<p>Next, run the <code>cargo uibless tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs</code> command on the test file. This command compiles the file and captures the exact diagnostic output into a corresponding <code>.stderr</code> file.</p>
<p>The command is expected to fail. The output will report "unmatched diagnostics" because the pattern has correctly fired, but the test file does not yet contain any annotations describing this expected output. The important part of the output is the full stderr section, which shows the exact error message generated by your pattern:</p>
<pre><code class="language-bash"> cargo uibless tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.15s
     Running tests/compile-test.rs (target/debug/deps/compile_test-251936bcca420e4b)
tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs ... FAILED

FAILED TEST: ...

error: there were 1 unmatched diagnostics
 --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:5:15
  |
5 |     unsafe { *mem::transmute::&lt;*const *const T, *const *const ()&gt;(&amp;val) }
  |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Error[rpl::wrong_assumption_of_fat_pointer_layout]: wrong assumption of fat pointer layout
  |

error: there were 1 unmatched diagnostics
  --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:10:15
   |
10 |     unsafe { *mem::transmute::&lt;*mut *mut T, *mut *mut ()&gt;(&amp;mut val) }
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Error[rpl::wrong_assumption_of_fat_pointer_layout]: wrong assumption of fat pointer layout
   |

error: expected error patterns, but found none

full stderr:
error: wrong assumption of fat pointer layout
  --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:5:15
   |
LL |     unsafe { *mem::transmute::&lt;*const *const T, *const *const ()&gt;(&amp;val) }
   |              -^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |              ||
   |              |ptr transmute here
   |              try to get data ptr from first 8 bytes here
   |
   = help: the Rust Compiler does not expose the layout of fat pointers
   = note: `#[deny(rpl::wrong_assumption_of_fat_pointer_layout)]` on by default

error: wrong assumption of fat pointer layout
  --&gt; tests/ui/cve/cve_2020_35881_test/cve_2020_35881_test.rs:10:15
   |
LL |     unsafe { *mem::transmute::&lt;*mut *mut T, *mut *mut ()&gt;(&amp;mut val) }
   |              -^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |              ||
   |              |ptr transmute here
   |              try to get data ptr from first 8 bytes here
   |
   = help: the Rust Compiler does not expose the layout of fat pointers

error: aborting due to 2 previous errors
</code></pre>
<h3 id="step-3-annotate-the-source-file"><a class="header" href="#step-3-annotate-the-source-file">Step 3: Annotate the Source File</a></h3>
<p>Now, copy the primary error message from the generated <code>.stderr</code> content and add it as a special comment in your <code>.rs</code> test file. The testing framework uses these comments to verify that the compiler produces the correct error.</p>
<p>The syntax is <code>//~^ ERROR: message</code>.</p>
<ul>
<li>
<p><code>//~</code> is a directive to the test harness.</p>
</li>
<li>
<p><code>^</code> points to the line immediately above the comment.</p>
</li>
<li>
<p><code>ERROR:</code> specifies the diagnostic level.</p>
</li>
<li>
<p><code>message</code> is the expected primary error text.</p>
</li>
</ul>
<p>Update your cve_2020_35881_test.rs file as follows:</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

pub unsafe fn get_data&lt;T: ?Sized&gt;(val: *const T) -&gt; *const () {
    unsafe { *mem::transmute::&lt;*const *const T, *const *const ()&gt;(&amp;val) }
    //~^ ERROR: wrong assumption of fat pointer layout
}

pub unsafe fn get_data_mut&lt;T: ?Sized&gt;(mut val: *mut T) -&gt; *mut () {
    unsafe { *mem::transmute::&lt;*mut *mut T, *mut *mut ()&gt;(&amp;mut val) }
    //~^ ERROR: wrong assumption of fat pointer layout
}

fn main() {}</code></pre></pre>
<h3 id="step-4-run-the-test-to-verify"><a class="header" href="#step-4-run-the-test-to-verify">Step 4: Run the Test to Verify</a></h3>
<p>Finally, run the UI test suite to confirm that the actual output from the compiler matches your annotations.</p>
<pre><code class="language-bash">cargo uitest
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
